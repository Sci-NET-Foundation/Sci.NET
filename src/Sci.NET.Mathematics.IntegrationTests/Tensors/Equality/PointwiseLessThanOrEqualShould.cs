// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.
// <auto-generated />

using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using Sci.NET.Mathematics.Backends.Devices;
using Sci.NET.Mathematics.Intrinsics;
using Sci.NET.Mathematics.Numerics;
using Sci.NET.Mathematics.Tensors;
using Sci.NET.Tests.Framework.Assertions;
using Sci.NET.Tests.Framework.Integration;

namespace Sci.NET.Mathematics.IntegrationTests.Tensors.Equality;

public class PointwiseLessThanOrEqualShould : IntegrationTestBase
{
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenBf16Scalar(IDevice device)
    {
        PerformScalarTest<BFloat16>(device, BFloat16.CreateChecked(10), BFloat16.CreateChecked(10), true);
        PerformScalarTest<BFloat16>(device, BFloat16.CreateChecked(11), BFloat16.CreateChecked(10), false);
        PerformScalarTest<BFloat16>(device, BFloat16.CreateChecked(9), BFloat16.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp16Scalar(IDevice device)
    {
        PerformScalarTest<Half>(device, Half.CreateChecked(10), Half.CreateChecked(10), true);
        PerformScalarTest<Half>(device, Half.CreateChecked(11), Half.CreateChecked(10), false);
        PerformScalarTest<Half>(device, Half.CreateChecked(9), Half.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp32Scalar(IDevice device)
    {
        PerformScalarTest<float>(device, float.CreateChecked(10), float.CreateChecked(10), true);
        PerformScalarTest<float>(device, float.CreateChecked(11), float.CreateChecked(10), false);
        PerformScalarTest<float>(device, float.CreateChecked(9), float.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp64Scalar(IDevice device)
    {
        PerformScalarTest<double>(device, double.CreateChecked(10), double.CreateChecked(10), true);
        PerformScalarTest<double>(device, double.CreateChecked(11), double.CreateChecked(10), false);
        PerformScalarTest<double>(device, double.CreateChecked(9), double.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI8Scalar(IDevice device)
    {
        PerformScalarTest<sbyte>(device, sbyte.CreateChecked(10), sbyte.CreateChecked(10), true);
        PerformScalarTest<sbyte>(device, sbyte.CreateChecked(11), sbyte.CreateChecked(10), false);
        PerformScalarTest<sbyte>(device, sbyte.CreateChecked(9), sbyte.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU8Scalar(IDevice device)
    {
        PerformScalarTest<byte>(device, byte.CreateChecked(10), byte.CreateChecked(10), true);
        PerformScalarTest<byte>(device, byte.CreateChecked(11), byte.CreateChecked(10), false);
        PerformScalarTest<byte>(device, byte.CreateChecked(9), byte.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI16Scalar(IDevice device)
    {
        PerformScalarTest<short>(device, short.CreateChecked(10), short.CreateChecked(10), true);
        PerformScalarTest<short>(device, short.CreateChecked(11), short.CreateChecked(10), false);
        PerformScalarTest<short>(device, short.CreateChecked(9), short.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU16Scalar(IDevice device)
    {
        PerformScalarTest<ushort>(device, ushort.CreateChecked(10), ushort.CreateChecked(10), true);
        PerformScalarTest<ushort>(device, ushort.CreateChecked(11), ushort.CreateChecked(10), false);
        PerformScalarTest<ushort>(device, ushort.CreateChecked(9), ushort.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI32Scalar(IDevice device)
    {
        PerformScalarTest<int>(device, int.CreateChecked(10), int.CreateChecked(10), true);
        PerformScalarTest<int>(device, int.CreateChecked(11), int.CreateChecked(10), false);
        PerformScalarTest<int>(device, int.CreateChecked(9), int.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU32Scalar(IDevice device)
    {
        PerformScalarTest<uint>(device, uint.CreateChecked(10), uint.CreateChecked(10), true);
        PerformScalarTest<uint>(device, uint.CreateChecked(11), uint.CreateChecked(10), false);
        PerformScalarTest<uint>(device, uint.CreateChecked(9), uint.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI64Scalar(IDevice device)
    {
        PerformScalarTest<long>(device, long.CreateChecked(10), long.CreateChecked(10), true);
        PerformScalarTest<long>(device, long.CreateChecked(11), long.CreateChecked(10), false);
        PerformScalarTest<long>(device, long.CreateChecked(9), long.CreateChecked(10), true);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU64Scalar(IDevice device)
    {
        PerformScalarTest<ulong>(device, ulong.CreateChecked(10), ulong.CreateChecked(10), true);
        PerformScalarTest<ulong>(device, ulong.CreateChecked(11), ulong.CreateChecked(10), false);
        PerformScalarTest<ulong>(device, ulong.CreateChecked(9), ulong.CreateChecked(10), true);
    }

    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenBf16SmallVector(IDevice device)
    {
        PerformTest<BFloat16>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenBf16Vector(IDevice device)
    {
        PerformTest<BFloat16>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenBf16Matrix(IDevice device)
    {
        PerformTest<BFloat16>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenBf16Tensor(IDevice device)
    {
        PerformTest<BFloat16>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp16SmallVector(IDevice device)
    {
        PerformTest<Half>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp16Vector(IDevice device)
    {
        PerformTest<Half>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp16Matrix(IDevice device)
    {
        PerformTest<Half>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp16Tensor(IDevice device)
    {
        PerformTest<Half>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp32SmallVector(IDevice device)
    {
        PerformTest<float>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp32Vector(IDevice device)
    {
        PerformTest<float>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp32Matrix(IDevice device)
    {
        PerformTest<float>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp32Tensor(IDevice device)
    {
        PerformTest<float>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp64SmallVector(IDevice device)
    {
        PerformTest<double>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp64Vector(IDevice device)
    {
        PerformTest<double>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp64Matrix(IDevice device)
    {
        PerformTest<double>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenFp64Tensor(IDevice device)
    {
        PerformTest<double>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI8SmallVector(IDevice device)
    {
        PerformTest<sbyte>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI8Vector(IDevice device)
    {
        PerformTest<sbyte>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI8Matrix(IDevice device)
    {
        PerformTest<sbyte>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI8Tensor(IDevice device)
    {
        PerformTest<sbyte>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU8SmallVector(IDevice device)
    {
        PerformTest<byte>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU8Vector(IDevice device)
    {
        PerformTest<byte>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU8Matrix(IDevice device)
    {
        PerformTest<byte>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU8Tensor(IDevice device)
    {
        PerformTest<byte>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI16SmallVector(IDevice device)
    {
        PerformTest<short>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI16Vector(IDevice device)
    {
        PerformTest<short>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI16Matrix(IDevice device)
    {
        PerformTest<short>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI16Tensor(IDevice device)
    {
        PerformTest<short>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU16SmallVector(IDevice device)
    {
        PerformTest<ushort>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU16Vector(IDevice device)
    {
        PerformTest<ushort>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU16Matrix(IDevice device)
    {
        PerformTest<ushort>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU16Tensor(IDevice device)
    {
        PerformTest<ushort>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI32SmallVector(IDevice device)
    {
        PerformTest<int>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI32Vector(IDevice device)
    {
        PerformTest<int>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI32Matrix(IDevice device)
    {
        PerformTest<int>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI32Tensor(IDevice device)
    {
        PerformTest<int>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU32SmallVector(IDevice device)
    {
        PerformTest<uint>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU32Vector(IDevice device)
    {
        PerformTest<uint>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU32Matrix(IDevice device)
    {
        PerformTest<uint>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU32Tensor(IDevice device)
    {
        PerformTest<uint>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI64SmallVector(IDevice device)
    {
        PerformTest<long>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI64Vector(IDevice device)
    {
        PerformTest<long>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI64Matrix(IDevice device)
    {
        PerformTest<long>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenI64Tensor(IDevice device)
    {
        PerformTest<long>(new Shape(128, 64, 32), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU64SmallVector(IDevice device)
    {
        PerformTest<ulong>(new Shape(16), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU64Vector(IDevice device)
    {
        PerformTest<ulong>(new Shape(256), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU64Matrix(IDevice device)
    {
        PerformTest<ulong>(new Shape(128, 64), device);
    }
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_GivenU64Tensor(IDevice device)
    {
        PerformTest<ulong>(new Shape(128, 64, 32), device);
    }

    private static void PerformScalarTest<TNumber>(IDevice device, TNumber leftValue, TNumber rightValue, bool shouldBe1)
        where TNumber : unmanaged, INumber<TNumber>
    {
        // Arrange
        using var left = new Scalar<TNumber>(leftValue, device.GetTensorBackend(), true);
        using var right = new Scalar<TNumber>(rightValue, device.GetTensorBackend(), true);
        using var expectedResult = new Scalar<TNumber>(shouldBe1 ? TNumber.One : TNumber.Zero, device.GetTensorBackend());

        // Act
        var result = left.PointwiseLessThanOrEqual(right);

        result.Backward();

        // Assert
        result.Value.Should().BeEquivalentTo(expectedResult.Value);
        left.Gradient!.Memory[0].Should().Be(TNumber.One);
        right.Gradient!.Memory[0].Should().Be(TNumber.One);
    }

    [SuppressMessage("Security", "CA5394:Do not use insecure randomness", Justification = "Not required to be secure")]
    private static void PerformTest<TNumber>(Shape shape, IDevice device)
        where TNumber : unmanaged, INumber<TNumber>
    {
        // Arrange
        Tensor.Random.Seed(42, device);
        var minValue = GenericMath.IsFloatingPoint<TNumber>() ? TNumber.CreateChecked(-500.0) : GenericMath.MinValue<TNumber>();
        var maxValue = GenericMath.IsFloatingPoint<TNumber>() ? TNumber.CreateChecked(500.0) : GenericMath.MaxValue<TNumber>() / TNumber.CreateChecked(2);

        using var left = Tensor.Random.Uniform(shape, minValue, maxValue, device: device).WithGradient();
        using var right = Tensor.Random.Uniform(shape, minValue, maxValue, device: device).WithGradient();
        using var expectedResult = Tensor.Zeros<TNumber>(shape, device);

        for (var i = 0L; i < shape.ElementCount; i++)
        {
            expectedResult.Memory[i] = left.Memory[i] <= right.Memory[i] ? TNumber.One : TNumber.Zero;
        }

        // Act
        var result = left.PointwiseLessThanOrEqual(right);

        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedResult.ToArray(), TNumber.CreateChecked(1e-6f));
        left.Gradient!.Should().NotBeNull();
        left.Gradient!.Should().HaveApproximatelyEquivalentElements(Tensor.Ones<TNumber>(shape).ToArray(), TNumber.CreateChecked(1e-6f));
        right.Gradient!.Should().NotBeNull();
        right.Gradient!.Should().HaveApproximatelyEquivalentElements(Tensor.Ones<TNumber>(shape).ToArray(), TNumber.CreateChecked(1e-6f));
    }
}
