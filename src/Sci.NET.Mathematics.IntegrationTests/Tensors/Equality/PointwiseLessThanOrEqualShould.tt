<#@ template language="C#" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    var scalarTestCases = new List<ScalarTestState>()
    {
        new ScalarTestState("Bf16", "BFloat16"),
        new ScalarTestState("Fp16", "Half"),
        new ScalarTestState("Fp32", "float"),
        new ScalarTestState("Fp64", "double"),
        new ScalarTestState("I8", "sbyte"),
        new ScalarTestState("U8", "byte"),
        new ScalarTestState("I16", "short"),
        new ScalarTestState("U16", "ushort"),
        new ScalarTestState("I32", "int"),
        new ScalarTestState("U32", "uint"),
        new ScalarTestState("I64", "long"),
        new ScalarTestState("U64", "ulong")
    };
    
    var nonScalarTestCases = NonScalarTestState.GenerateTestCases();
#>// Copyright (c) Sci.NET Foundation. All rights reserved.
// Licensed under the Apache 2.0 license. See LICENSE file in the project root for full license information.
// <auto-generated />

using System.Diagnostics.CodeAnalysis;
using System.Numerics;
using Sci.NET.Mathematics.Backends.Devices;
using Sci.NET.Mathematics.Intrinsics;
using Sci.NET.Mathematics.Numerics;
using Sci.NET.Mathematics.Tensors;
using Sci.NET.Tests.Framework.Assertions;
using Sci.NET.Tests.Framework.Integration;

namespace Sci.NET.Mathematics.IntegrationTests.Tensors.Equality;

public class PointwiseLessThanOrEqualShould : IntegrationTestBase
{
<#
    foreach (var function in scalarTestCases)
    {
#>
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_Given<#= function.FunctionName #>Scalar(IDevice device)
    {
        PerformScalarTest<<#= function.TypeName #>>(device, <#= function.TypeName #>.CreateChecked(10), <#= function.TypeName #>.CreateChecked(10), true);
        PerformScalarTest<<#= function.TypeName #>>(device, <#= function.TypeName #>.CreateChecked(11), <#= function.TypeName #>.CreateChecked(10), false);
        PerformScalarTest<<#= function.TypeName #>>(device, <#= function.TypeName #>.CreateChecked(9), <#= function.TypeName #>.CreateChecked(10), true);
    }
<#
    }
#>

<#
    foreach (var function in nonScalarTestCases)
    {
#>
    [Theory]
    [MemberData(nameof(ComputeDevices))]
    public void ReturnCorrectResult_Given<#= function.FunctionName #>(IDevice device)
    {
        PerformTest<<#= function.TypeName #>>(new Shape(<#= function.Shape #>), device);
    }
<#
    }
#>

    private static void PerformScalarTest<TNumber>(IDevice device, TNumber leftValue, TNumber rightValue, bool shouldBe1)
        where TNumber : unmanaged, INumber<TNumber>
    {
        // Arrange
        using var left = new Scalar<TNumber>(leftValue, device.GetTensorBackend(), true);
        using var right = new Scalar<TNumber>(rightValue, device.GetTensorBackend(), true);
        using var expectedResult = new Scalar<TNumber>(shouldBe1 ? TNumber.One : TNumber.Zero, device.GetTensorBackend());

        // Act
        var result = left.PointwiseLessThanOrEqual(right);

        result.Backward();

        // Assert
        result.Value.Should().BeEquivalentTo(expectedResult.Value);
        left.Gradient!.Memory[0].Should().Be(TNumber.One);
        right.Gradient!.Memory[0].Should().Be(TNumber.One);
    }

    [SuppressMessage("Security", "CA5394:Do not use insecure randomness", Justification = "Not required to be secure")]
    private static void PerformTest<TNumber>(Shape shape, IDevice device)
        where TNumber : unmanaged, INumber<TNumber>
    {
        // Arrange
        Tensor.Random.Seed(42, device);
        var minValue = GenericMath.IsFloatingPoint<TNumber>() ? TNumber.CreateChecked(-500.0) : GenericMath.MinValue<TNumber>();
        var maxValue = GenericMath.IsFloatingPoint<TNumber>() ? TNumber.CreateChecked(500.0) : GenericMath.MaxValue<TNumber>() / TNumber.CreateChecked(2);

        using var left = Tensor.Random.Uniform(shape, minValue, maxValue, device: device).WithGradient();
        using var right = Tensor.Random.Uniform(shape, minValue, maxValue, device: device).WithGradient();
        using var expectedResult = Tensor.Zeros<TNumber>(shape, device);

        for (var i = 0L; i < shape.ElementCount; i++)
        {
            expectedResult.Memory[i] = left.Memory[i] <= right.Memory[i] ? TNumber.One : TNumber.Zero;
        }

        // Act
        var result = left.PointwiseLessThanOrEqual(right);

        result.Backward();

        // Assert
        result.Should().HaveApproximatelyEquivalentElements(expectedResult.ToArray(), TNumber.CreateChecked(1e-6f));
        left.Gradient!.Should().NotBeNull();
        left.Gradient!.Should().HaveApproximatelyEquivalentElements(Tensor.Ones<TNumber>(shape).ToArray(), TNumber.CreateChecked(1e-6f));
        right.Gradient!.Should().NotBeNull();
        right.Gradient!.Should().HaveApproximatelyEquivalentElements(Tensor.Ones<TNumber>(shape).ToArray(), TNumber.CreateChecked(1e-6f));
    }
}
<#+
    public class ScalarTestState
    {
        public string FunctionName { get; set; }
        
        public string TypeName { get; set; }
        
        public string IsEqual { get; set; }

        public ScalarTestState(
            string functionName,
            string typeName)
        {
            FunctionName = functionName;
            TypeName = typeName;
        }
    }

    public class NonScalarTestState
    {
        public string FunctionName { get; set; }
        
        public string TypeName { get; set; }
        
        public string Shape { get; set; }

        public static List<NonScalarTestState> GenerateTestCases()
        {
            var typeNames = new List<(string FunctionName, string TypeName)>
            {
                ("Bf16", "BFloat16"),
                ("Fp16", "Half"),
                ("Fp32", "float"),
                ("Fp64", "double"),
                ("I8", "sbyte"),
                ("U8", "byte"),
                ("I16", "short"),
                ("U16", "ushort"),
                ("I32", "int"),
                ("U32", "uint"),
                ("I64", "long"),
                ("U64", "ulong")
            };
            
            var shapesWithDifferences = new List<(string Shape, string ShapeName)>
            {
                ("16", "SmallVector"),
                ("256", "Vector"),
                ("128, 64", "Matrix"),
                ("128, 64, 32", "Tensor"),
            };
            
            var testCases = new List<NonScalarTestState>();
            
            foreach (var (functionName, typeName) in typeNames)
            {
                foreach (var (shape, shapeName) in shapesWithDifferences)
                {
                    testCases.Add(new NonScalarTestState
                    {
                        FunctionName = $"{functionName}{shapeName}",
                        Shape = shape,
                        TypeName = typeName
                    });
                }
            }
            
            return testCases;
        }
    }
#>